{
    "collab_server" : "",
    "contents" : "###Prototype\nlibrary(reshape2)\nlibrary(dplyr)\n\nDELIMITER <- \";\"\nORIENTATION <- 1  #0 if samples in columns, 1 if samples in rows\n\ntest.file <- read.delim(file = \"test.txt\", header = T, sep = '\\t', check.names = F)\ntest.inv <- read.delim(file = \"test_inv.txt\", header = T, sep = '\\t', check.names = F)\n\n#####Data importing and formatting functions###################################################################\ndetermine.delimiter <- function(string){\n  #Determines what character separates the different levels of taxonomy\n  string <- as.character(string)\n  char.list <- unlist(strsplit(x= string, split = ''))   #Get a vector of all characters\n  for (delim in c(\":\", \";\", \"|\")){\n    if (delim%in%char.list){\n      return(delim)\n    }\n  }\n  stop(\"Could not determine delimeter\")\n}\n\ninvert <- function(x){\n  #inverts matrix so that samples are the columns\n  inverted <- t(x)\n  colnames(inverted) <- inverted[1,]\n  inverted <- inverted[-1,]\n}\n\nformat.taxonomy <- function(unformatted.string, delimiter=DELIMITER){\n  #Takes in an unformatted taxonomy string and the delimiter and produces a vector of the taxonomies without the titles\n  #Assumes the taxonomy is separated by underscores ex. \"s__Enterococcus;g__faecium\"\n  \n  #Split by delimiter\n  tax.split <- unlist(strsplit(x = as.character(unformatted.string), split = delimiter))\n  taxonomies <- c()\n  \n  for (level in tax.split){\n    #Split by the underscore and store the last value as the taxonomy name\n    level.split <- unlist(strsplit(x=level, split = '_'))\n    taxonomies <- c(taxonomies, rev(level.split)[1])\n    #get the level of the taxonomy by taking everything else that isn't an underscore\n    \n  }\n  \n  return(taxonomies)\n}\n\nformat.taxonomy.titles <- function(unformatted.string, delimiter=DELIMITER){\n  #Takes in the unformatted taonomy string and produces a vector of the taxonomy titles\n  \n  #Split by delimiter\n  tax.split <- unlist(strsplit(x = as.character(unformatted.string), split = delimiter))\n  titles <- c()\n  \n  for (level in tax.split){\n    level.split <- unlist(strsplit(x=level, split = '_'))\n    level.format <- paste(x = head(x = level.split, n =  -1), collapse = '')\n    titles <- c(titles, level.format)\n  }\n  \n  return(titles)\n}\n\napply.format.taxonomy <- function(row){\n  #Function for apply that takes a row and adds in the taxonomy of all the present levels\n  #Assumes that the unformatted taxonomy is in a column calles \"unformatted.taxonomy\n  \n  tax.vector <- format.taxonomy(row[\"unformatted.taxonomy\"], delimiter = DELIMITER)\n  \n  \n}\n\n########################################################################################\n\n###Formatting output functions\n\n##MELTED RELATIVE ABUNDANCE\nrelative.abundance <- function(DF){\n  #Takes in the melted data frame and makes it relative abundance\n  sums <- summarize(group_by(dat.melt, variable), SUM=sum(value))\n  result <- apply(dat.melt, 1, function(x){\n    return(as.numeric(x[\"value\"])/subset(sums, variable==x[\"variable\"])$SUM)\n  })\n}\n\ncollapse.to.level <- function(DF, LEVEL){\n  ##Collapse a data frame to a level\n  return(summarize(group_by(DF, LEVEL, variable), value = sum(value)))\n}\n\nmake.other.category <- function(DF, LEVEL, NUMBER){\n  #Makes the other category for a melted data frame\n}\n\n\n########################################################################################\n\n#####Workflow###########################################################################\n\n#Load in the data\ndat <- test.file\nif (ORIENTATION){\n  dat <- invert(test.file)\n  class(dat) <- \"numeric\"\n  dat <- data.frame(dat, check.names = F)\n}\n#Get relative abundance\n##Needs to be data frame with first column is sample names\nsums <- apply(dat, 2, sum)\n#NORMALIZE\ndat.relative <- NULL\nfor (i in seq(ncol(dat))){\n  dat.relative <- cbind(dat.relative, dat[,i]/sums[i])\n}\ncolnames(dat.relative) <- colnames(dat)\nrownames(dat.relative) <- rownames(dat)\ndat.relative <- data.frame(dat.relative, check.names = F)\n\n\n####Format taxonomy\n#Get vector of all taxonomies\ntaxonomy.list <- rownames(dat)\n#Get the delimiter\nDELIMITER <- determine.delimiter(taxonomy.list[1])\n#Get the number of taxonomy levels\nTAX.COUNT <- lengths(regmatches(x, gregexpr(DELIMITER, taxonomy.list[1]))) + 1 #taxonomy fields is the number of delimiters + 1\n#Create new columns for each taxonomy level\nlev.list <- c(\"L1\", \"L2\", \"L3\", \"L4\", \"L5\", \"L6\", \"L7\", \"L8\", \"L9\", \"L10\")[1:TAX.COUNT]\nfor (L in lev.list){\n  dat[[L]] <- NA\n  dat.relative[[L]] <- NA\n}\n\n#Add taxonomy columns to data frame\nfor (i in seq(nrow(dat))){\n  taxonomies <- format.taxonomy(rownames(dat[i,]))\n  for (j in seq(length(taxonomies))){\n    dat[i,lev.list[j]] <- taxonomies[j]\n    dat.relative[i,lev.list[j]] <- taxonomies[j]\n  }\n}\n\n#Melt data\ndat.melt <- melt(dat, id.vars = lev.list)\ndat.relative.melt <- melt(dat.relative, id.vars = lev.list)\n\n########################################################################################\n",
    "created" : 1530847201645.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1464984303",
    "id" : "93D45CDF",
    "lastKnownWriteTime" : 1531170564,
    "last_content_update" : 1531170564451,
    "path" : "C:/Users/Stephen/Desktop/taxonomy_solution/prototype.R",
    "project_path" : "prototype.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}